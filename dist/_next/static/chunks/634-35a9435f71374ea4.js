"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[634],{3768:(t,e,r)=>{function s(t,e){return"function"==typeof t?t(...e):!!t}function n(){}r.d(e,{G:()=>s,l:()=>n})},5041:(t,e,r)=>{r.d(e,{n:()=>c});var s=r(2115),n=r(4560),i=r(7165),u=r(5910),o=r(2020),a=class extends u.Q{#t;#e=void 0;#r;#s;constructor(t,e){super(),this.#t=t,this.setOptions(e),this.bindMethods(),this.#n()}bindMethods(){this.mutate=this.mutate.bind(this),this.reset=this.reset.bind(this)}setOptions(t){let e=this.options;this.options=this.#t.defaultMutationOptions(t),(0,o.f8)(this.options,e)||this.#t.getMutationCache().notify({type:"observerOptionsUpdated",mutation:this.#r,observer:this}),e?.mutationKey&&this.options.mutationKey&&(0,o.EN)(e.mutationKey)!==(0,o.EN)(this.options.mutationKey)?this.reset():this.#r?.state.status==="pending"&&this.#r.setOptions(this.options)}onUnsubscribe(){this.hasListeners()||this.#r?.removeObserver(this)}onMutationUpdate(t){this.#n(),this.#i(t)}getCurrentResult(){return this.#e}reset(){this.#r?.removeObserver(this),this.#r=void 0,this.#n(),this.#i()}mutate(t,e){return this.#s=e,this.#r?.removeObserver(this),this.#r=this.#t.getMutationCache().build(this.#t,this.options),this.#r.addObserver(this),this.#r.execute(t)}#n(){let t=this.#r?.state??(0,n.$)();this.#e={...t,isPending:"pending"===t.status,isSuccess:"success"===t.status,isError:"error"===t.status,isIdle:"idle"===t.status,mutate:this.mutate,reset:this.reset}}#i(t){i.j.batch(()=>{if(this.#s&&this.hasListeners()){let e=this.#e.variables,r=this.#e.context;t?.type==="success"?(this.#s.onSuccess?.(t.data,e,r),this.#s.onSettled?.(t.data,null,e,r)):t?.type==="error"&&(this.#s.onError?.(t.error,e,r),this.#s.onSettled?.(void 0,t.error,e,r))}this.listeners.forEach(t=>{t(this.#e)})})}},l=r(6715),h=r(3768);function c(t,e){let r=(0,l.jE)(e),[n]=s.useState(()=>new a(r,t));s.useEffect(()=>{n.setOptions(t)},[n,t]);let u=s.useSyncExternalStore(s.useCallback(t=>n.subscribe(i.j.batchCalls(t)),[n]),()=>n.getCurrentResult(),()=>n.getCurrentResult()),o=s.useCallback((t,e)=>{n.mutate(t,e).catch(h.l)},[n]);if(u.error&&(0,h.G)(n.options.throwOnError,[u.error]))throw u.error;return{...u,mutate:o,mutateAsync:u.mutate}}},5453:(t,e,r)=>{r.d(e,{v:()=>a});var s=r(2115);let n=t=>{let e;let r=new Set,s=(t,s)=>{let n="function"==typeof t?t(e):t;if(!Object.is(n,e)){let t=e;e=(null!=s?s:"object"!=typeof n||null===n)?n:Object.assign({},e,n),r.forEach(r=>r(e,t))}},n=()=>e,i={setState:s,getState:n,getInitialState:()=>u,subscribe:t=>(r.add(t),()=>r.delete(t))},u=e=t(s,n,i);return i},i=t=>t?n(t):n,u=t=>t,o=t=>{let e=i(t),r=t=>(function(t,e=u){let r=s.useSyncExternalStore(t.subscribe,()=>e(t.getState()),()=>e(t.getInitialState()));return s.useDebugValue(r),r})(e,t);return Object.assign(r,e),r},a=t=>t?o(t):o},6786:(t,e,r)=>{function s(t,e){let r;try{r=t()}catch(t){return}return{getItem:t=>{var s;let n=t=>null===t?null:JSON.parse(t,null==e?void 0:e.reviver),i=null!=(s=r.getItem(t))?s:null;return i instanceof Promise?i.then(n):n(i)},setItem:(t,s)=>r.setItem(t,JSON.stringify(s,null==e?void 0:e.replacer)),removeItem:t=>r.removeItem(t)}}r.d(e,{KU:()=>s,Zr:()=>i});let n=t=>e=>{try{let r=t(e);if(r instanceof Promise)return r;return{then:t=>n(t)(r),catch(t){return this}}}catch(t){return{then(t){return this},catch:e=>n(e)(t)}}},i=(t,e)=>(r,i,u)=>{let o,a={storage:s(()=>localStorage),partialize:t=>t,version:0,merge:(t,e)=>({...e,...t}),...e},l=!1,h=new Set,c=new Set,d=a.storage;if(!d)return t((...t)=>{console.warn(`[zustand persist middleware] Unable to update item '${a.name}', the given storage is currently unavailable.`),r(...t)},i,u);let m=()=>{let t=a.partialize({...i()});return d.setItem(a.name,{state:t,version:a.version})},p=u.setState;u.setState=(t,e)=>{p(t,e),m()};let v=t((...t)=>{r(...t),m()},i,u);u.getInitialState=()=>v;let f=()=>{var t,e;if(!d)return;l=!1,h.forEach(t=>{var e;return t(null!=(e=i())?e:v)});let s=(null==(e=a.onRehydrateStorage)?void 0:e.call(a,null!=(t=i())?t:v))||void 0;return n(d.getItem.bind(d))(a.name).then(t=>{if(t){if("number"!=typeof t.version||t.version===a.version)return[!1,t.state];if(a.migrate){let e=a.migrate(t.state,t.version);return e instanceof Promise?e.then(t=>[!0,t]):[!0,e]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}return[!1,void 0]}).then(t=>{var e;let[s,n]=t;if(r(o=a.merge(n,null!=(e=i())?e:v),!0),s)return m()}).then(()=>{null==s||s(o,void 0),o=i(),l=!0,c.forEach(t=>t(o))}).catch(t=>{null==s||s(void 0,t)})};return u.persist={setOptions:t=>{a={...a,...t},t.storage&&(d=t.storage)},clearStorage:()=>{null==d||d.removeItem(a.name)},getOptions:()=>a,rehydrate:()=>f(),hasHydrated:()=>l,onHydrate:t=>(h.add(t),()=>{h.delete(t)}),onFinishHydration:t=>(c.add(t),()=>{c.delete(t)})},a.skipHydration||f(),o||v}}}]);